const fs = require('fs');
const babel = require("babel-core");

const classASTTemplate = function(className, comments, superClassName) {
	comments = comments == null ? [] : comments;
	return {
		type: 'ClassDeclaration',
		leadingComments: comments.map(function(line) {
			return {
				type: 'CommentLine',
				value: ' ' + line
			};
		}),
		id: {
			type: 'Identifier',
			name: className
		},
		superClass: superClassName == null ? null : {
			type: 'Identifier',
			name: superClassName
		},
		body: {}
	};
};
const classDef = {
	Controller: classASTTemplate('Controller', [
		'following code are auto-generated by owl',
		'controller is stateful'
	], 'CommonController'),
	Layout: classASTTemplate('Layout', [
		'layout is stateless'
	]),
	Mocker: classASTTemplate('Mocker', [
		'mocker is stateless'
	])
};
const defaultConstructor = {
	type: 'ClassMethod',
	kind: 'constructor',
	async: false,
	computed: false,
	expression: false,
	generator: false,
	static: false,
	key: {
		type: 'Identifier',
		name: 'constructor'
	},
	params: [{
		type: 'Identifier',
		name: 'externalOptions'
	}],
	body: [{
		type: 'BlockStatement',
		body: [{
			type: 'ExpressionStatement',
			expression: {
				type: 'AssignmentExpression',
				operator: '=',
				left: {
					type: 'MemberExpression',
					computed: false,
					object: {
						type: 'ThisExpression'
					},
					property: {
						type: 'Identifier',
						name: 'external'
					}
				},
				right: {
					type: 'Identifier',
					name: 'externalOptions'
				}
			}
		}]
	}]
};
const classConstructors = {
	Controller: defaultConstructor,
	Mocker: defaultConstructor,
	Layout: defaultConstructor
};
const exportSection = {
	type: 'ExpressionStatement',
	expression: {
		type: 'AssignmentExpression',
		operator: '=',
		left: {
			type: 'MemberExpression',
			computed: false,
			object: {
				type: 'Identifier',
				name: 'module'
			},
			property: {
				type: 'Identifier',
				name: 'exports'
			}
		},
		right: {
			type: 'FunctionExpression',
			async: false,
			expression: false,
			generator: false,
			params: [{
				type: 'Identifier',
				optional: false,
				name: 'options'
			}],
			body: {
				type: 'BlockStatement',
				body: [{
					type: 'ReturnStatement',
					argument: {
						type: 'NewExpression',
						callee: {
							type: 'Identifier',
							name: 'Controller'
						},
						arguments: [{
							type: 'ObjectExpression',
							properties: [{
								name: 'layout',
								class: 'Layout'
							}, {
								name: 'mocker',
								class: 'Mocker'
							}].map(function(arg) {
								return {
									type: 'ObjectProperty',
									computed: false,
									method: false,
									shorthand: false,
									key: {
										type: 'Identifier',
										name: arg.name
									},
									value: {
										type: 'NewExpression',
										callee: {
											type: 'Identifier',
											name: arg.class
										},
										arguments: [{
											type: 'Identifier',
											name: 'options'
										}]
									}
								};
							})
						}, {
							type: 'Identifier',
							name: 'options'
						}]
					}
				}]
			}
		}
	}
};

let ast = {
	loadFileAST: function(file) {
		if (file === null) {
			return;
		}

		let code = fs.readFileSync(file, 'utf8');
		let result = babel.transform(code, {
			presets: ['react'],
			plugins: ['transform-react-jsx']
		});
		this.state.ast = result.ast;
		// console.log(result.ast);
		// console.log(this.getControllerASTNode());
		// console.log(babel.transformFromAst(this.astWrapNodeToAST(this.getControllerASTNode())).code);
		// console.log(babel.transformFromAst(this.astWrapNodeToAST(this.getLayoutASTNode())).code);
		// console.log(babel.transformFromAst(this.astWrapNodeToAST(this.getMockerASTNode())).code);
		// console.log(babel.transformFromAst(this.astWrapNodeToAST(exportSection)).code);

		// fs.writeFileSync(file, babel.transformFromAst(
		// 	this.astWrapNodeToAST(this.getMockerASTNode(), exportSection).code));
		return this.state.ast;
	},
	getFileAST: function() {
		return this.state.ast;
	},
	getControllerASTNode: function() {
		return this.astFindClass('Controller');
	},
	getLayoutASTNode: function() {
		return this.astFindClass('Layout');
	},
	getMockerASTNode: function() {
		return this.astFindClass('Mocker');
	},
	astFindClass: function(name) {
		let variables = this.getFileAST().program.body.filter(function(node) {
			return this.astCheckVariableByName(node, name);
		}.bind(this));
		return this.astBuildClassNode(
						variables.length > 0 ? variables[0] : {}, 
						name);
	},
	astCheckVariableByName: function(node, name) {
		return node.type === 'ClassDeclaration' 
					&& node.id.type === 'Identifier'
					&& node.id.name === name;
	},
	astWrapNodeToAST: function() {
		// console.log(Array.prototype.slice.call(arguments));
		return {
			type: 'Program',
			body: Array.prototype.slice.call(arguments)
		};
	},
	astBuildClassNode: function(node, name) {
		this.astBuildNode(node, classDef[name]);
		// this.astAppendConstructorToClass(node, classConstructors[name]);
		return node;
	},
	astBuildNode: function(node, nodeProperties) {
		return Object.keys(nodeProperties).reduce(function(node, propertyName) {
			let type = typeof nodeProperties[propertyName];
			if (type === 'function') {
				node[propertyName] = nodeProperties[propertyName]();
			} else if (type === 'object') {
				let value = node[propertyName];
				value = value == null ? {} : value;
				node[propertyName] = this.astBuildNode(value, nodeProperties[propertyName]);
			} else {
				node[propertyName] = nodeProperties[propertyName];
			}
			return node;
		}.bind(this), node);
	},
	astAppendConstructorToClass: function(node, constructor) {
		let methods = node.body.body;
		if (methods == null) {
			methods = [];
			node.body.body = methods;
		}
		let orgConstructor = methods.filter(function(method) {
			return method.type == 'ClassMethod' && method.kind == 'constructor';
		});
		if (orgConstructor.length == 0) {
			methods.push(constructor);
		}
	}
};

module.exports = {
	ASTMixin: ast
};